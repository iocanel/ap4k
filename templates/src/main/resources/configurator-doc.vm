##
## First pass: collect package names
##
#set ($map = {})
#foreach ($m in ${model.values()})
#set ($pkg = $m.getPackageName().split("\."))
#set ($key = $pkg[2])
#set ($ignore = $map.put($key, $m))
#end
##
## Print Package Heading
##
#foreach ($entry in $map.entrySet())
** $entry.key
#end
| Configurator | Target | Description |
|-
#foreach ($m in ${model.values()})
#set ($superclass = $m.getExtendsList().get(0))
#if ($superclass.getName().endsWith("Configurator"))
#elseif ($superclass.getDefinition().getExtendsList().size() == 1)
#set ($superclass = $superclass.getDefinition().getExtendsList().get(0))
#end
#if ($m.isAbstract())
#elseif ($superclass.getName().endsWith("Configurator") && $superclass.getArguments().size() == 1)
#set ($target = $superclass.getArguments().get(0))
#set ($target = $target.toString().replaceAll("Builder","").replaceAll("Fluent$",""))
## Description
##
#set ($description = "")
#set  ($comments = $m.comments)
#foreach  ($comment in $comments)
#if ($comment.startsWith("@"))
#set ($description = $description)
#elseif ($description.isEmpty())
#set ($description = $comment)
#else
#set ($description = $description + " " + $comment)
#end
#end
## Inherited configurators will have no comments/description (not retained in the jar) so we can use description to filter them!
#if (!$description.isEmpty())
| ${m.name} | $target | $description |
#end
#end
#end
